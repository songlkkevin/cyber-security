# Homework4

## T1

NOP sled是一串NOP指令，执行时不产生任何效果，这样跳到任何一个NOP都可以最后执行到malicious code

某些操作系统以及处理器会开启地址虚拟化，所以很难确定注入的malicious code的准确地址。不过可以知道大概的地址范围，所以可以通过在之前添加一些NOP指令，然后在NOP指令之后添加malicious code。当return指令执行时，会跳转到一个范围以内的地址，若在NOP之内则会一直执行NOP直到最后运行到malicious code。

## T2
1. 权限操作：如给攻击者提高权限，使其可以访问系统的重要文件。或者降低其余用户的权限等等。
2. 窃取数据：因为可以利用一个shell且可能拥有较高的权限，攻击者可以通过shell中的命令以及脚本等方式窃取数据，发送至攻击者。
3. 文件系统操作：攻击者可以删除，移动，复制文件等等。破坏文件系统的完整性。
4. 网络操作：攻击者可以通过Polymorphic Netcat等工具建立网络连接，进行端口扫描、文件传输和远程shell访问等。也可以进行其余的网络操作，如利用compromised的机器进行Dos攻击等等。
5. 改变系统配置：攻击者可以改变系统的配置，如修改系统环境变量，改变启动项，修改防火墙策略等等。


## T3

### a
在程序中str1和str2地址连续，str1处在str2。gets并不做边界检查，所以当输入的字符串长度超过str1的长度时，会覆盖str2的内容。攻击如下:

![](./img/buffer_overflow.png)

### b
在现在的gcc中默认开启堆栈保护，正常情况下编译出的可执行文件若使用了栈溢出攻击则会被系统检测到并终止程序。所以需要关闭堆栈保护，可以通过编译时加上`-fno-stack-protector`参数来关闭堆栈保护。

另外也可以通过限制输入的长度来防止栈溢出攻击，比如用fgets限定输入的长度。

## T4
| register| value |
|-----|--------|
| ecx | 0x3000 |
| edx | 0x899c |
| eip | 0x4000 |

| address | value|
|-----|--------|
| 0x9000 | 0x3333 |
| 0x9004 | 0x5000 |
| 0x9008 | 0x4000 |
| 0x900c | 0x6666 |
| 0x9010 | 0x6000 |

首先在0x4000取出值0x3333至eax,然后跳至0x3000之后跳至0x5000将0x333从eax放至ebx，之后跳至0x3000，然后跳至0x4000将0x6666取至eax，最后跳至0x6000将0x3333存入0x6666。
其中0x3000用于分支，0x4000用于取值，0x5000用于移动寄存器，0x6000用于存值。

## T5

uint32_t是无符号int型，所以在代码片段：
```c
if (8192 - (nlen+1) <= vlen ){ /* DANGER */ 
    vlen = 8192 - (nlen+1); 
}
```
若将hdr->vlen设为-1(在unsigned中是最大的值0xffff),hdr->nlen设为8192。则最后的值最后vlen将被置为0xffff,那么memcpy将会拷贝0xffff个字节，这将导致堆栈溢出。